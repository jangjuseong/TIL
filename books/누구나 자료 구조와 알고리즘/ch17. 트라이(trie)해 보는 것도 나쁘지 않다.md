# 17장 트라이(trie)해 보는 것도 나쁘지 않다

스마트폰의 자동 완성 기능이 어떻게 동작하는지 궁금했던 적 있는가? 단어를 자동으로 완성하기 위해 스마트폰은 전체 단어 사전에 접근한다. 하지만 이러한 단어들을 어떤 자료 구조에 저장할까?

트라이는 자동 완성이나 자동 수정과 같은 중요한 기능을 지원하므로 17장에 예제에서는 텍스트 처리 애플리케이션에서 어떻게 트라이(trie)를 활용하는지 보이겠다. 물론 IP 주소나 전화번호를 처리하는 애플리케이션 등에도 쓰인다.

# 17.1 트라이

트리의 한 종류인 `트라이(trie)`는 자동 완성 같은 텍스트 기반 기능에 이상적이다. 트라이가 어떻게 동작하는지 살펴보기 앞서 왜 트라이라고 발음하는지부터 보자.

트라이라는 단어는 사실 추출(retrieval)이라는 단어에 유래한다. 따라서 엄밀히 말해 “트리”로 발음해야 한다. 하지만 트리는 모든 트리 기반 자료 구조에 보편젹으로 쓰이는 용어이므로 혼동을 막기 위해 주로 트라이(try)로 발음한다.

트라이는 이 책에 나오는 다른 자료 구조들처럼 명쾌하게 설명되지 않는다. 여러 교재마다 트라이를 조금씩 다르게 구현한다. 이 책에서는 가장 간단하고 이해하기 쉬운 구현으로 택했으나 얼마든지 다르게 구현할 수 있다. 어떤 구현이든 대강의 개념은 같다.

## 17.1.1 트라이 노드

대부분의 트리처럼 트라이도 다른 노드를 가리키는 노드들의 컬렉션이다. 하지만 트라이는 이진 트리가 아니다. 이진 트리는 노드에 셋 이상의 자식이 있을 수 없으나 트라이 노드는 자식 노드 `개수에 제한이 없다`.

다음은 자바스크립트로 구현한 TrieNode 클래스다

```jsx
class TrieNode {
  constructor() {
    this.children = {};
  }
}
```

보다시피 트라이 노드는 해시 테이블만 포함한다.

다시 말하지만 해시 테이블에서 키는 개개 문자열이고 값은 다른 TrieNode 인스턴스다.

## 17.1.2 트라이 클래스

완벽하게 트라이를 생성하려면 루트 노드를 추적하는 Trie 클래스도 별도로 필요하다.

```jsx
class Trie {
  constructor() {
    this.root = new TrieNode();
  }
```

이 클래스는 루트 노드를 가리키는 this.root 변수를 관리한다. 이렇게 구현해서 새 Trie를 생성하면 빈 TrieNode가 루트가 된다.

이 장을 진행하면서 다른 트라이 연산 메서드도 이 Trie 클래스에 추가하겠다.

# 17.2 단어 저장

![IMG_0901.heic](<17%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5(trie)%E1%84%92%E1%85%A2%20%E1%84%87%E1%85%A9%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%BA%E1%84%83%E1%85%A9%20%E1%84%82%E1%85%A1%E1%84%88%E1%85%B3%E1%84%8C%E1%85%B5%20%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%83%E1%85%A1%201acd02ebb9874d828fc02e04a77c0423/IMG_0901.heic>)

위 그림은 트라이를 새롭게 표현한 것이다. 각 해시 테이블의 키를 그 자식 노드를 가리키는 화살표 옆에 두었다.

## 17.2.1 별표(asterisk)의 필요성

“\*”는 단어의 일부도 단어일 수 있음을 나타내는 데 꼭 필요하다.

실제 애플리케이션에 쓰이는 트라이는 단어를 수천 개 포함한다. 꼭 영어 전체가 아니더라도 최소한 가장 흔히 쓰이는 단어라도 포함한다.

# 17.3 트라이 검색

검색은 가장 대표적인 트라이 연산으로서 트라이에 어떤 문자열이 있는지 알아내는 것이다. 검색의 목적은 크게 두 가지인데, 하나는 문자열이 `완전한` 단어인지 알아내는 것, 또 하나는 문자열이 최소한 어떤 단어의 `접두사`인지(즉 어떤 단어의 앞부분인지) 알나내는 것이다. 둘 다 비슷하지만 후자인 접두사를 찾는 검색을 구현하겠다. 접두사를 찾다 보면 완전한 단어도 자연스레 찾을 수 있다.

접두사 검색 알고리즘은 다음과 같은 단계를 수행한다.

1. currentNode라는 변수를 만든다. 알고리즘을 시작할 때 이 변수는 루트 노드를 가리킨다.
2. 검색 문자열의 각 문자를 순회한다.
3. 검색 문자열의 각 문자를 가리키며 currentNode에 그 문자를 키로 하는 자식이 있는지 본다.
4. 자식이 없으면 검색 문자열이 트라이에 없다는 뜻이니 None을 반환한다.
5. currentNode에 현재 문자를 키로 하는 자식이 있으면 currentNode를 그 자식 노드로 업데이트 한다. 이어서 2단계로 돌아가 검색 문자열 내 각 문자를 계속 순회한다.
6. 검색 문자열을 끝까지 순회했으면 검색 문자열을 찾았다는 뜻이다.

## 17.3.1 코드 구현: 트라이 검색

Trie 클래스에 다음의 search 메서드를 추가해 트라이 검색을 구현하자.

```jsx
class Trie {
  constructor() {
    this.root = new TrieNode();
  }

  search(word) {
    let currentNode = this.root;
    for (let char of word) {
      if (currentNode.children[char]) {
        currentNode = currentNode.children[char];
      } else {
        return null;
      }
    }
    return currentNode;
  }
}
```

그냥 true를 반환하지 않고 현재 노드를 반환하는 이유는 잠시 뒤 설명할 자동 완성 기능을 지원하기 위해서다.

# 17.4 트라이 검색의 효율성

트라이 검색의 장점은 엄청난 효율성이다.

필요한 단계 수를 분석해 보자.

앞선 알고리즘은 검색 문자열의 각 문자를 한 번에 하나씩 살펴본다. 그러면서 각 노드의 해시 테이블을 사용해 한 단계만에 적절한 자식 노드를 찾는다. 알다시피 해시 테이블 룩업에는 딱 O(1) 시간이 걸린다. 따라서 알고리즘은 `검색 문자열 내 문자 수 만큼` 단계가 걸린다.

이는 정렬된 배열에 이진 검색을 수행하는 것 보다 훨씬 빠르다.

트라이 검색은 빅 오로 나타내기 약간 까다롭다. 단계 수가 검색 문자열의 길이에 따라 달라지기 때문에 상수가 아니며, 따라서 O(1)이라 말할 수 없다. 또한 N은 일반적으로 자료 구조 내 데이터 양을 말하는데 O(N)은 오해의 소지가 있다. N은 트라이 내 노드 수를 뜻하며 이 값은 검색 문자열 내 문자 수보다 훨씬 크다.

많은 교재에서 이 복잡도를 O(K)라 부른다. K는 검색 문자열 내 문자 수다. N이 아닌 문자면 되지만 K로 정했다.

검색 문자열마다 길이가 다르므로 O(K)가 상수는 아니지만 한 가지 의미 있는 면에서 상수 시간과 비슷하다. 상수가 아닌 알고리즘은 대부분 처리해야 할 데이터양에 따라 좌우된다. 즉 데이터 N이 커질수록 알고리즘이 느려진다. 하지만 O(K) 알고리즘에서는 트라이가 엄청나게 커지더라도 검색 속도에 영향이 없다. 문자 3개로 된 문자열이면 O(K) 알고리즘은 트라이가 얼마나 크든 항상 3단계만 걸린다. 알고리즘 속도에 영향을 미치는 요인은 사용 가능한 전체 데이터가 아니라 입력 크기 뿐이다. 그래서 O(K) 알고리즘이 매우 효율적인 것이다.

# 17.5 트라이 삽입

트라이에 새 단어를 삽입하는 과정은 기존 단어를 검색하는 과정과 비슷하다.

삽입 알고리즘은 다음과 같다.

1. currentNode라는 변수를 만든다. 알고리즘을 시작할 때 이 변수는 루트 노드를 가리킨다.
2. 검색 문자열의 각 문자를 순회한다.
3. 검색 문자열의 각 문자를 가리키며 currentNode에 그 문자를 키로 하는 자식이 있는지 본다.
4. 자식이 있으면 currentNode를 그 자식 노드로 업데이트 하고 2단계로 돌아가 검색 문자열 내 다음 문자로 넘어간다.
5. currentNode에 현재 문자와 일치하는 자식 노드가 없으면 자식 노드를 생성하고 currentNode를 이 새 노드로 업데이트한다. 이어서 2단계로 돌아가 검색 문자열 내 다음 문자로 넘어간다.
6. 삽입할 단어의 마지막 문자까지 삽입했으면 마지막 노드에 “\*” 자식을 추가해 단어가 끝났음을 알린다.

## 17.5.1 코드 구현: 트라이 삽입

다음은 Trie 클래스에 넣을 insert 메서드다. 앞서 봤던 search 메서드와 거의 비슷해 보인다.

```jsx
insert(word) {
  let currentNode = this.root;
  for (let char of word) {
    if (currentNode.children[char]) {
      currentNode = currentNode.children[char];
    } else {
      const newNode = new TrieNode();
      currentNode.children[char] = newNode;
      currentNode = newNode;
    }
  }
  currentNode.children["*"] = null;
}
```

검색처럼 트라이 삽입에도 O(K) 단계가 걸린다. 마지막에 “\*”를 추가하니 정확하게 세면 K + 1 단계이지만 상수는 무시하므로 속도를 O(K)로 표현한다.

# 17.6 자동 완성 개발

## 17.6.1 단어 수집

Trie 클래스에 추가할 다음 메서드는 트라이 내 모든 단어를 배열로 반환하는 메서드다. 다음의 collectAllWords라는 메서드는 특정 노드에서 시작해 트라이 내 모든 단어를 수집한다.

```jsx
collectAllWords(node = null, word = '', words = []) {
  const currentNode = node || this.root;

  for (const key in currentNode.children) {
    if (key === '*') {
      words.push(word);
    } else {
      this.collectAllWords(currentNode.children[key], word + key, words);
    }
  }

  return words;
}
```

## 17.6.2 재귀 연습(walk-through)

“can”과 “cat”으로 단어 수집 과정 연습(책 참조)

# 17.7 자동 완성 마무리

```jsx
autocomplete(prefix) {
  const currentNode = this.search(prefix);
  if (!currentNode) {
    return null;
  }
  return this.collectAllWords(currentNode, prefix);
}
```

autocomplete 메서드는 사용자가 입력하기 시작한 문자열인 prefix를 인자로 받는다. 먼저 prefix가 트라이에 존재하는지 검색한다. search 메서드는 접두사가 트라이에 없으면 None을 반환한다. 반면 접두사가 트라이에 있으면 접두사의 마지막 문자가 들어 있는 트라이 노드를 반환한다.

앞서 언급했듯이 단어를 찾았을 때 단순히 true를 반환하도록 search를 구현할 수도 있었다. 마지막 노드를 반환한 이유는 search 메서드를 활용해 자동 완성 기능을 지원하기 위해서다.

# 17.8 값을 포함하는 트라이: 자동 완성 업그레이드

조금 더 생각해 보면 사용자가 입력할 만한 단어를 전부 표시하는 것이 꼭 훌륭한 자동 완성 기능은 아니다. 예를 들어 옵션 16개를 사용자에게 보여주는 것은 너무 과할 수 있으니 가장 널리 쓰이는 단어만 추려서 보여주는 편이 낫다.

앞선 트라이 구현에서 키 `*`를 할당할 때 그 값을 널로 넣었다. 값에는 아무 의미가 없어 키 `*`에만 초점을 맞췄기 때문이다. 하지만 이 값을 활용해 단어 자체에 단어의 사용 빈도 같은 데이터를 추가로 저장할 수 있다. 간단한 설명을 위해 그 정도를 1부터 10으로 한정하겠다. 1이 가장 덜 쓰이는 단어, 10이 가장 많이 쓰이는 단어다.
