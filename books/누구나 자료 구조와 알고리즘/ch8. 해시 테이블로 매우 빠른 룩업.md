# 8장 해시 테이블로 매우 빠른 룩업

# 8.1 해시 테이블

- 대부분의 프로그래밍 언어는 해시 테이블(hash table)이라는 자료 구조를 포함하며, 해시 테이블에는 빠른 읽기라는 놀랍고 엄청난 능력이 있다.
- 해시 테이블은 다양한 프로그래밍 언어에서 서로 다른 이름으로 불린다
  - 해시
  - 맵
  - 해시 맵
  - 딕셔너리
  - 연관 배열

# 8.2 해시 함수로 해싱

- 문자를 가져와 숫자로 변환하는 과정을 해싱(hashing)이라고 부른다.
- 글자를 특정 숫자로 변환하는 데 사용한 코드를 해시 함수(hash function)라 부른다.
- 이 밖에도 해시 함수는 많음
  - 해시 함수가 유효하려면 동일한 문자열을 해시 함수에 적용할 때마다 항상 동일한 숫자로 변환해야 한다.

# 8.3 재미와 이익, 특히 이익을 남길 유의어 사전 만들기

- Quickasaurus에서 단어를 룩업하면 가능한 유의어를 모두 반환하는 대신 유의어를 딱 하나만 반환할 것
  - Quickasaurus는 가상의 유의어 사전 앱
- 단어를 곱셉 해시 함수를 사용하여 해싱

# 8.4 해시 테이블 룩업

해시 테이블에서 각 값의 위치는 키로 결정되기 때문에, 해시 테이블의 값 룩업은 전형적으로 `O(1)`인 이유이다.

## 8.4.1 단반향(one-directional) 룩업

- 키를 사용해 값을 찾을 때만 O(1) 룩업 가능
- 값을 이용해 연관된 키를 찾을 때는 해시 테이블의 빠른 룩업 기능을 활용할 수 없다
- 언어에 따라 다르지만 어떤 언어는 키를 값 바로 옆에 저장한다.
  - 이렇게 저장하면 충돌에서 매우 유용하다

# 8.5 충돌 해결

- 키를 해싱했을 때 이미 데이터가 들어있는 경우가 있다.
  - 이미 채워진 셀에 데이터를 추가하는 것을 `충돌`이라 한다.

### 충돌 해결 방법

- `분리 연결법(seperate chaining)`
  - 충돌을 해결하는 고전적인 방법
  - 충돌이 발생했을 때 하나의 값을 넣는 대신 배열로의 참조를 넣는 방법
- 최악의 경우 해시 테이블 룩업 성능은 사실상 O(N)이다
  - 대부분의 프로그래밍 언어에서 해시 테이블에 충돌이 거의 없도록 이를 구현하고 대신 처리하고 있다.
  - 그러나 내부 동작 방식을 이해함으로써 해시 테이블이 어떻게 O(1) 성능을 간신히 유지하는지 이해할 수 있다.

# 8.6 효율적인 해시 테이블 만들기

### 해시 테이블의 효율성

- 해시 테이블에 얼마나 많은 데이터를 저장하는가
- 해시 테이블에서 얼마나 많은 셀을 쓸 수 있는가
- 어떤 해시 함수를 사용하는가

⇒ 좋은 해시 함수란 사용 가능한 모든 셀에 데이터를 분산시키는 함수

- 데이터를 넓게 퍼뜨릴 수록 충돌이 적다

## 8.6.1 훌륭한 충돌 조정

좋은 해시 테이블은 많은 메모리를 낭비하지 않으면서 균형을 유지하며 충돌을 피한다.

### 부하율(load factor)

- 데이터와 셀 간의 비율
- (예) 원소를 14개 저장할 생각이라면 셀이 20개가 있어야 함 → 이상적인 부하율 7 / 10 = 0.7

# 8.7 해시 테이블로 데이터 조직

- 해시 테이블로 조건부 로직을 없앨 수 있다.
- 다양한 속성을 갖는 객체를 표현할 때도 흔히 쓰인다.
  - 배열 안에 여러 해시 테이블을 넣음으로써 다양한 목록을 생성할 수 있다.

# 8.8 해시 테이블로 속도 올리기

해시 테이블은 쌍으로 된 데이터와 완벽하게 들어 맞지만 쌍이 아닌 데이터라도 코드를 빠르게 만들 때 쓰일 수 있다.

1. 배열을 해시 테이블로 변환
2. 각 수를 키로 저장해서 각 수와 연관된 값에 불리언 true를 할당
3. 예를 들어, 72이라는 값이 있으면 true를 반환, 없으면 false(null, nil, undefined ??)를 반환
   - (파이썬으로 실행해보니 값이 없어서 key error 발생함)

## 8.8.1 배열 부분 집합

두 배열을 비교해 한 쪽이 다른 쪽의 부분 집합인지 알려주는 함수를 어떻게 작성할까?

### 중첩 루프

- O(N×M)

### 해시 테이블

```jsx
function isSubset(array1, array2) {
  let largerArray;
  let smallerArray;
  let hashTable;

  // 어느 배열이 더 작은지 알아낸다.
  if (array1.length > array2.length) {
    largerArray = array1;
    smallerArray = array2;
  } else {
    largerArray = array2;
    smallerArray = array1;
  }

  // largerArray의 모든 항목을 hashTable에 저장한다.
  for (const value of largerArray) {
    hashTable[value] = true;
  }

  // smallerArray의 각 항목을 순회하며 hashTable에 없는 항목이면 false를 반환한다.
  for (const value of smallerArray) {
    if (!hashTable[value]) {
      return flase;
    }

    // false를 반환하지 않고 코드에서 여기까지 왔다면 samllerArray의 모든 항목이 largerArray에 들어 있다는 뜻이다.
    return true;
  }
}
```

두 배열을 합친 총 항목의 수를 N이라고 하면 각 항목을 한 번씩 순회했으므로 위 알고리즘은 O(N)이다.

해시 테이블을 ‘인덱스’로 사용하는 이 기법은 배열을 여러 번 검색해야 하는 알고리즘에 자주 쓰인다. 알고리즘에서 배열의 값을 계속 검색해야 한다면 매 검색에만 최대 N단계씩 걸리기 때문이다.
