# 3장 빅 오 표기법

`빅 오 표기법`: 시간 복잡도를 쉽게 소통할 목적으로 자료 구조와 알고리즘의 효율성을 간결하고 일관된 언어로 설명하기 위해 차용한 수학적 개념을 형식화한 표현

# 3.1 빅 오: 원소가 N개일 때 몇 단계가 필요할까?

O(N)

- 선형 시간 알고리즘
- 배열 선형 검색

O(1)

- 가장 빠른 알고리즘
- 상수 시간을 갖는 알고리즘
- 배열 읽기

# 3.2 빅 오의 본질

`빅 오의 본질`: 데이터가 늘어날 때 알고리즘의 성능이 어떻게 바뀌는지를 뜻함

## 3.2.1 빅 오의 본질 더 파고들기

데이터의 크기가 1,000,000인 O(1,000,000)이 있다고 가정해보자.

- N=1 일 때는 O(N)이 더 적은 단계가 소요되지만, O(1,000,000)이 O(N)보다 더 효율적인 알고리즘이라고 할 수 있다.
- 변화가 생기는 일정량의 데이터가 항상 있을 것이고, O(N)은 그 순간부터 무한대까지 더 많은 단계가 걸리기 때문이다.

## 3.2.2 같은 알고리즘, 다른 시나리오

별도로 명시하지 않는 한 빅 오 표기법은 일반적으로 **최악의 시나리오**를 의미한다. 

# 3.3 세 번째 유형의 알고리즘

### 이진 검색

- 데이터가 커질 수록 단계 수가 늘어나므로 O(1)이라 표현할 수 없다
- 검색하고 있는 원소 수보다 단계 수가 훨씬 적으므로 O(N)이라고도 할 수 없다.
- O(1)과 O(N) 사이에 어딘가에 있음
- 이진 검색은 `O(logN)`
    - 로그 시간의 복잡도
    - 데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘

# 3.4 로가리즘

`로가리즘(logarithm)`: 로그의 원래 표현

- 로가리즘과 알고리즘이 매우 비슷하게 보이지만 두 단어는 아무 관련 없음

### log2(8)을 쉽게 설명

- 1이 될 때까지 8을 2로 몇 번 나눠야 할까? ⇒ 3

# 3.5 O(logN) 해석

- 컴퓨터 과학에서 O(logN)은 O(log2(N))과 같다
- O(logN)은 원소가 하나가 될 때까지 데이터 원소를 계속해서 반으로 줄이는 만큼의 단계 수가 걸린다는 뜻이다.

# 3.6 실제 예제

주요 데이터가 배열이 아닌 수인 경우 시간 복잡도를 계산하는 핵심 질문이 달라진다.