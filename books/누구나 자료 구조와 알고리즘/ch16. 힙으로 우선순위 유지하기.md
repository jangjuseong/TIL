# 16장 힙으로 우선순위 유지하기

`힙`은 데이터 세트에서 가장 큰 또는 가장 작은 데이터 원소를 계속 알아내야 할 때 특히 유용하다.

# 16.1 우선순위 큐

`우선순위 큐(priority queue)`는 삭제와 접근에 있어 전형적인 큐와 흡사하나 삽입에 있어 정렬된 배열과 비슷한 리스트다. 즉 우선순위 큐 `앞`에서만 데이터에 접근하고 삭제하되 데이터를 삽입할 때는 데이터를 늘 특정 순서대로 정렬시킨다.

우선순위 큐가 유용하게 쓰이는 대표적인 예는 병원 응급실의 중증도 분류체계 관리 애플리케이션이다. 응급실에서는 도착한 순서를 엄격히 따져 환자를 치료하지 않는다. 대신 중증도를 따져 치료한다. 치명상을 입은 환자가 갑자기 도착하면 감기에 걸린 환자가 몇 시간 먼저 도착했더라도 그 환자를 큐 맨 앞에 놓는다.

우선순위 큐는 추상 데이터 타입의 한 예다. 다시 말해 보다 기초적인 다른 자료 구조로 구현할 수 있다. 우선순위 큐를 간단하게 구현하려면 정렬된 배열을 이용하면 된다. 즉 배열을 사용하되 다음의 제약을 가한다.

- 데이터를 삽입할 때 항상 적절한 순서를 유지한다.
- 데이터는 배열 끝에서만 삭제한다(배열 끝이 우선순위 큐의 앞이다).

방식은 이해하기 쉬우나 효율성을 분석해보자. 우선순위 큐의 주요 연산은 삭제와 삽입이다.

우선순위 큐는 배열 끝을 우선순위 큐의 앞으로 삼으므로, 이렇게 하면 항상 배열 끝에서 삭제하니 O(1)이다.

정렬된 배열에 삽입은 새 데이터를 알아내기 위해 배열 원소 N개를 모두 확인해야 하니 O(N)이었다(데이터를 넣을 자리가 배열 앞쪽이라 해도 어차피 나머지 데이터를 전부 오른쪽으로 시프트해야 한다).

따라서 배열 기반 우선순위 큐는 삭제가 O(1), 삽입이 O(N)이다. 우선순위 큐에 항목이 많아지면 O(N) 삽입으로 인해 애플리케이션에 원치 않은 지연이 발생할 수 있다.

그래서 컴퓨터 과학자는 우선순위 큐에서 보다 효율적인 기반으로 쓰일 또 다른 자료 구조를 찾아 냈다. 이 자료 구조가 바로 힙이다.

# 16.2 힙

힙에는 몇 가지 종류가 있으나 `이진 힙(binary heap)`을 주로 다루겠다.

이진 힙은 특수한 종류의 이진 트리다. 이진 트리는 각 노드에 최대 자식 노드가 둘인 트리였다(15장에 나오는 이진 `탐색` 트리 역시 특수한 종류의 이진 트리였다).

이진 힙에도 최대 힙(max-heap)과 최소 힙(min-heap)이라는 두 종류가 있다. 우선 최대 힙을 다루겠으나 둘 간에 큰 차이가 없음을 곧 알게 될 것이다.

`힙`은 다음의 조건을 따르는 이진 트리다.

- 각 노드의 값은 그 노드의 모든 자손 노드의 값보다 커야 한다. 이 규칙을 `힙 조건(heap condition)`이라 부른다.
- 트리는 `완전(complete)`해야 한다(무슨 뜻인지 잠시 후 설명하겠다)

## 16.2.1 힙 조건

힙 조건이란 각 노드의 값이 그 노드의 모든 자손 노드보다 커야 한다는 뜻이다.

정반대의 힙 조건으로, 즉 각 노드가 자손보다 작은 값을 갖도록 힙을 구성할 수도 있다. 이러한 힙을 앞서 언급했던 최소 힙이라 부른다. 이 책에서는 각 노드가 그 노드의 모든 자손 노드보다 큰 최대 힙에 초점을 맞추겠다. 궁극적으로 최대 힙을 쓰든 최소 힙을 쓰든 차이는 미미하다. 두 힙은 힙 조건만 반대일 뿐 그 밖에 모든 면에서 동일하다. 근본적인 개념은 같다.

## 16.2.2 완전 트리

완전 트리는 빠진 노드 없이 노드가 완전히 채워진 트리다. 따라서 트리의 각 레벨을 왼쪽부터 오른쪽으로 읽었을 때 모든 자리마다 노드가 있다. 하지만 바닥 줄에는 빈 자리가 있을 수 있다. 단 빈 자리의 오른쪽으로 어떤 노드도 없어야 한다.

![IMG_0891.heic](16%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%B5%E1%86%B8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%8B%E1%85%AE%E1%84%89%E1%85%A5%E1%86%AB%E1%84%89%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%B1%20%E1%84%8B%E1%85%B2%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20f791167c0b044c128a52f5aabda0f696/IMG_0891.heic)

위의 그림처럼 트리 바닥 줄에 빈 자리가 있으나 빈 자리의 오른쪽으로 어떤 노드도 없으므로 사실상 완전하다.

# 16.3 힙 속성

힙 조건에 따라 힙은 특정 방식으로 정렬되지만 이러한 정렬은 힙에서 값을 검색하는 데 전혀 도움이 되지 않는다. 예를 들어 위의 그림에서 값 3을 검색한다고 하자. 루트 노드인 100에서 시작했을 때 왼쪽 자손과 오른쪽 자손 중 어느 쪽을 검색해야 할까? 이진 탐색 트리라면 당연히 3이 100의 왼쪽 자손일 것이다. 하지만 힙에서는 3이 100의 조상이라는 것만 안다. 어느 자식을 검색해야 할지 전혀 알 수 없다.

따라서 힙은 이진 탐색 트리에 비해 `약한 정렬(weakly ordered)`이라고 말한다. 힙에는 자손이 조상보다 클 수 없다는 `분명한` 순서가 있지만 값을 검색하기에는 부족하다.

알다시피 힙 속성은 힙에서는 루트 노드가 항상 최댓값이라는 점이다.

힙의 주요 연산은 삽입과 삭제다. 앞서 말했듯이 힙에서 검색하려면 각 노드를 검사해야 하므로 힙으로는 대개 검색 연산을 구현하지 않는다(또한 힙에는 단순히 루트 노드의 값만 보는 “일기” 연산이 선택적으로 있을 수 있다).

힙에는 `마지막 노드(last node)`가 있다. 힙의 마지막 노드는 바닥 레벨에서 가장 오른쪽에 있는 노드다. 위의 그림에서 마지막 노드는 바닥 줄에서 가장 오른쪽에 있는 노드인 3이다.

# 16.4 힙 삽입

힙에 새 값을 삽입하려면 다음 알고리즘을 수행한다.

1. 새 값을 포함하는 노드를 생성하고 바닥 레벨의 가장 오른쪽 노드 옆에 삽입한다. 즉 이 값이 힙의 마지막 노드가 된다.
2. 이어서 새로 삽입한 노드와 그 부모 노드를 비교한다.
3. 새 노드가 부모 노드보다 크면 새 노드와 부모 노드를 스왑한다.
4. 새 노드보다 큰 부모 노드를 만날 때까지 3단계를 반복하며 새 노드를 힙 위로 올린다.

새 노드를 힙 위로 올리는 과정을 노드를 위로 트리클링(trickling)한다고 표현한다. 때로는 오른쪽으로, 때로는 왼쪽으로 올라가지만 어쨌든 올바른 위치에 안착할 때 까지 항상 위로 올라간다.

힙 삽입의 효율성은 O(logN)이다. 15장에서 봤듯이 노드가 N개인 이진 트리는 약 log(N)개 줄을 갖는다. 최악의 경우 새 값을 꼭대기 줄까지 트리클링해서 올려야 하므로 최대 log(N)단계가 걸린다.

# 16.5 마지막 노드 탐색

마지막 노드 자리를 어떻게 찾을까?

컴퓨터에는 눈이 없으니 힙을 트리 구조 그림처럼 줄로 묶어서 보지 못한다. 루트 노드만 보이고 링크를 따라 자식 노드에 갈 수 있다. 컴퓨터가 새 값을 넣을 자리를 찾는 알고리즘을 어떻게 만들까?

근본적으로 힙에서 검색하기 불가능하듯이 힙의 마지막 노드(혹은 새 마지막 노드가 들어갈 다음으로 비어있는 자리)도 모든 노드를 검사하지 않고는 효율적으로 찾을 수 없다.

그렇다면 어떻게 다음으로 노드가 들어갈 자리를 찾을까? 잠시 뒤 설명하겠지만 우선은 이 이슈를 마지막 노드 문제(Problem of the Last Node)라 부르자. 나중에 다시 다루겠다.

# 16.6 힙 삭제

힙에서 값을 삭제하려면 루트 노드만 삭제할 수 있다는 점을 먼저 알아야 한다. 이는 가장 높은 우선순위를 갖는 항목만 접근하고 삭제하는 우선 순위 큐의 동작 방식과 일치한다.

힙의 루트 노드를 삭제하는 알고리즘은 다음과 같다.

1. 마지막 노드를 루트 노드 자리로 옮긴다. 결과적으로 원래 루트 노드는 삭제된다.
2. 루트 노드를 적절한 자리까지 아래로 트리클링한다.

노드를 아래로 트리클링할 때 내려갈 수 있는 방향이 둘이므로 아래로의 트리클링은 위로의 트리클링보다 조금 더 복잡하다. 즉 왼쪽 자식과 스왑할 수도 있고 오른쪽 자식과 스왑할 수도 있다(반면 위로 트리클링할 때는 노드와 스왑할 부모가 딱 하나다)

아래로 트리클링하는 알고리즘은 다음과 같다. 명확하게 설명하기 위해 트리클링하는 노드를 “트리클 노드”라 부르겠다.

1. 트리클 노드의 두 자식을 확인해 어느쪽이 더 큰지 본다
2. 트리클 노드가 두 자식 노드 중 큰 노드보다 작으면 큰 노드와 트리클 노드를 스왑한다.
3. 트리클 노드에 그 노드보다 큰 자식이 없을 때 까지 1, 2단계를 반복한다.

트리클 노드와 두 자식 중 더 큰 노드를 스왑하는 이유는 작은 노드와 스왑하면 힙 조건이 바로 깨지기 때문이다.

힙에서 삭제하려면 루트부터 시작해 logN개 레벨을 거쳐 노드를 트리클링해야 하므로 삽입과 마찬가지로 시간 복잡도가 O(logN)이다

# 16.7 힙 대 정렬된 배열

힙의 효율성을 알았으니 이제 왜 힙이 우선순위 큐를 구현하는 훌륭한 방식인지 알아볼 차례다.

|      | 정렬된 배열 | 힙      |
| ---- | ----------- | ------- |
| 삽입 | O(N)        | O(logN) |
| 삭제 | O(1)        | O(logN) |

정렬된 배열은 삽입에 있어 힙보다 느리지만 삭제에 있어 힙보다 빠르다. 하지만 다음과 같은 이유로 힙을 선택하는 편이 더 낫다. O(1)이 엄청나게 빠르긴 해도 O(logN) 역시 `매우` 빠르다. 이에 비해 O(N)은 느리다.

|      | 정렬된 배열   | 힙        |
| ---- | ------------- | --------- |
| 삽입 | 느림          | 매우 빠름 |
| 삭제 | 엄청나게 빠름 | 매우 빠름 |

이렇게 보면 왜 힙을 선택하는 편이 나은지 보다 명확하다. 때로는 엄청 빠르고 때로는 느린 자료 구조보다는 일관되게 매우 빠른 자료 구조를 사용하는 편이 낫다.

우선순위 큐가 일반적으로 삽입과 삭제를 거의 비슷한 비율로 수행한다는 점에 주목할 필요가 있다. 들어 온 환자를 모두 치료해야 하는 응급실 예제를 떠올려 보자. 삽입과 삭제, 둘 다 빨라야 한다. 어느 한 연산이라도 느리면 우선순위 큐는 효율성이 떨어진다.

# 16.8 다시 살펴보는 마지막 노드 문제

힙 삭제 알고리즘이 간단해 보여도 마지막 노드 문제부터 풀어야 한다.

앞서 설명했듯이 삭제의 첫 번째 단계에서 마지막 노드를 루트 노드로 옮긴다. 하지만 그에 앞서 마지막 노드를 어떻게 찾을까?

마지막 노드 문제를 풀기 전에 왜 삽입과 삭제에 마지막 노드가 꼭 필요한지부터 알아보자. 새 값을 힙의 다른 위치에 삽입하면 안될까? 삭제할 때 루트 노드를 마지막 노드 대신 다른 노드와 대체할 수 없을까?

다른 노드와 바꾸는 경우의 수를 생각해보자. 힙이 불완전해진다는 사실을 곧 깨닫게 된다. 하지만 또 다른 질문이 떠오른다. 왜 힙에는 완전성(completeness)이 그토롤 `중요할까`?

이유는 `균형 잡힌` 힙으로 유지하고 싶어서다.

이러한 균형이 너무나 중요한 이유는 O(logN) 안에 연산이 가능하기 때문이다. 불균형이 심한 트리는 순회에 O(N)단계가 걸린다.

# 16.9 배열로 힙 구현하기

마지막 노드 찾기는 힙 연산의 핵심이고 또한 효율적으로 찾아야 하므로 주로 배열을 사용해 힙을 구현한다.

지금까지는 모든 트리가 (연결 리스트처럼) 링크로 연결된 독립적인 노드로 구성된다고 가정했으나 배열로도 힙을 구현할 수 있음을 보이겠다. 즉 힙 자체가 내부적으로 배열을 사용하는 추상 데이터 타입일 수 있다.

![IMG_0892.heic](16%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%B5%E1%86%B8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%8B%E1%85%AE%E1%84%89%E1%85%A5%E1%86%AB%E1%84%89%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%B1%20%E1%84%8B%E1%85%B2%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20f791167c0b044c128a52f5aabda0f696/IMG_0892.heic)

힙을 배열로 구현하는 이유는 마지막 노드 문제를 해결하기 위해서다. 어떻게 해결할까?

위의 그림처럼 힙을 구현하면 `마지막 노드는 항상 배열의 마지막 원소`다.

다음은 힙의 앞 부분을 자바스크립트로 구현한 것이다.

```jsx
class Heap {
  constructor() {
    this.data = [];
  }

  get rootNode() {
    return this.data[0];
  }

  get lastNode() {
    return this.data[this.data.length - 1];
  }
}
```

## 16.9.1 배열 기반 힙 순회

앞서 봤듯이 힙 삽입과 삭제 알고리즘이 가능하려면 힙을 트리클링할 수 있어야 한다. 그리고 이러한 트리클링이 가능하려면 노드의 부모나 자식에 접근해서 힙을 순회할 수 있어야 한다. 하지만 값이 전부 배열에 저장되어 있는데 노드에서 노드를 어떻게 이동할까? 단순히 각 노드의 링크를 따라가면 힙 순회가 간단할 것이다. 하지만 힙이 내부적으로 배열이므로 어떤 노드가 어떤 노드와 연결되는지 어떻게 알까?

흥미롭게 해결하는 방법이 있다. 앞서 설명했던 패턴대로 힙 노드에 인덱스를 할당하면 다음과 같은 힙 특성을 항상 만족한다.

- 어떤 노드의 왼쪽 자식을 찾으려면 (index \* 2) + 1 공식을 사용한다.
- 어떤 노드의 오른쪽 자식을 찾으려면 (index \* 2) + 2 공식을 사용한다.
- 어떤 노드의 부모를 찾으려면 (index - 1) / 2 공식을 사용한다.
  - 위 공식에서 정수 나눗셈을 사용한다는 점에 주목하자. 즉 소숫점 이하를 버린다.

```jsx
class Heap {
  constructor() {
    this.data = [];
  }

  get rootNode() {
    return this.data[0];
  }

  get lastNode() {
    return this.data[this.data.length - 1];
  }

  leftChildIndex(index) {
    return index * 2 + 1;
  }

  rightChildIndex(index) {
    return index * 2 + 2;
  }

  parentIndex(index) {
    return Math.floor((index - 1) / 2);
  }
}
```

## 16.9.2 코드 구현: 힙 삽입

```jsx
insert(value) {
    this.data.push(value);
    let newNodeIndex = this.data.length - 1;

    while (newNodeIndex > 0 && this.data[newNodeIndex] > this.data[this.parentIndex(newNodeIndex)]) {
      [this.data[this.parentIndex(newNodeIndex)], this.data[newNodeIndex]] = [this.data[newNodeIndex], this.data[this.parentIndex(newNodeIndex)]];
      newNodeIndex = this.parentIndex(newNodeIndex);
    }
```

## 16.9.3 코드 구현: 힙 삭제

delete 메서드가 핵심 메서드이지만 코드의 간결성을 위해 has_greater)child와 calculate_larger_child_index라는 두 헬퍼 메서드를 만들었다.

```jsx
delete() {
  this.data[0] = this.data.pop();
  let trickleNodeIndex = 0;

  while (this.hasGreaterChild(trickleNodeIndex)) {
    const largerChildIndex = this.calculateLargerChildIndex(trickleNodeIndex);
    [this.data[trickleNodeIndex], this.data[largerChildIndex]] = [this.data[largerChildIndex], this.data[trickleNodeIndex]];
    trickleNodeIndex = largerChildIndex;
  }
}

hasGreaterChild(index) {
  return (this.data[this.leftChildIndex(index)] && this.data[this.leftChildIndex(index)] > this.data[index]) ||
         (this.data[this.rightChildIndex(index)] && this.data[this.rightChildIndex(index)] > this.data[index]);
}

calculateLargerChildIndex(index) {
  if (!this.data[this.rightChildIndex(index)]) {
    return this.leftChildIndex(index);
  }

  if (this.data[this.rightChildIndex(index)] > this.data[this.leftChildIndex(index)]) {
    return this.rightChildIndex(index);
  } else {
    return this.leftChildIndex(index);
  }
}
```

## 16.9.4 대안 구현

내부적으로 배열을 써서 힙을 구현했으나 연결 리스트로도 구현할 수 있다.(이렇게 구현하면 2진수를 활용하는 다른 방법으로 마지막 노드 문제를 해결한다).

# 16.10 우선순위 큐로 쓰이는 힙

결국 힙의 약한 정렬이 굉장한 장점으로 작용했다. 완벽히 정렬할 필요가 없으니 새 값을 O(logN)시간에 삽입할 수 있다. 동시에 힙은 언제든 필요한 항목에, 즉 힙의 최댓값에 항상 접근할 수 있을만큼 정렬되어 있다.
