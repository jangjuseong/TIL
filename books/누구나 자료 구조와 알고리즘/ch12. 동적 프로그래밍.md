# 12장 동적 프로그래밍

재귀는 종종 O($2^N$)과 같은 가장 느린 빅 오 카테고리의 주된 요인이다. 12장에서는 이런 걸림돌을 찾고 문제점을 개선하는 방법을 배운다.

# 12.1 불필요한 재귀 호출

```jsx
function max(array) {
  if (array.length === 1) return array[0];

  if (array[0] > max(array.slice(1))) {
    return array[0];
  } else {
    return max(array.slice(1));
  }
}
```

위 코드는 잘 동작하지만, 비효율적인 부분이 존재한다. 코드에 `max(array.slice(1))` 가 조건문 앞과 뒤에 한 번씩, 두 번 나온다. 이렇게 되면 `max(array.slice(1))`를 호출할 때마다 재귀 호출이 쇄도하게 된다.

결과적으로 `max([1, 2, 3, 4])`를 호출하면 실제로 max 함수를 총 15번 호출한다.

이 중 **어떤** 호출은 정말 필요하지만 정말 필요없는 호출도 있다. 가령 max([4])는 꼭 호출해야 하지만 그 결과를 한 번만 계산해도 충분하다. 하지만 예제에서는 8번이나 호출한다.

# 12.2 빅 오를 위한 작은 개선

다행히도 이러한 추가적인 재귀 호출을 전부 없앨 손쉬운 방법이 있다. 코드에서 max를 딱 한번만 호출하고 그 결과를 변수에 저장하면 된다.

```jsx
function max(array) {
  if (array.length === 1) return array[0];

  const restMax = max(array.slice(1));

  if (array[0] > restMax) {
    return array[0];
  } else {
    return restMax;
  }
}
```

이렇게 간단히 수정해서 구현하면 max를 단 4번 호출한다.

비결은 필요한 함수 호출을 한 번만 수행하고 그 결과를 변수에 저장함으로써 함수를 다시 호출하지 않아도 되게 하는 것이다.

# 12.3 재귀의 효율성

개선된 두 번째 max 함수(12.2)는 배열 내 값 개수만큼 자신을 재귀적으로 호출한다. 이는 O(N)이다.

첫 번째 max 함수(12.1)는 O($2^N$)으로 매우 느린 알고리즘이다.

불필요한 재귀 호출을 피하는 것이 재귀를 빠르게 만드는 핵심 비결이다. 계산 결과를 변수에 저장하는 부분이 언뜻 봐서는 코드에서 아주 사소한 변화이더라도 궁극적으로 함수 속도를 O($2^N$)에서 O(N)으로 변화시킨다.

# 12.4 하위 문제 중첩

```jsx
function fib(n) {
  if (n === 0 || n === 1) {
    return n;
  }
  return fib(n - 2) + fib(n - 1); // 핵심 코드
}
```

⬆️ 피보나치 수열

`return fib(n - 2) + fib(n - 1);`

이 코드는 피보나치 수열에서 앞의 두 수를 합한다. 매우 간결한 재귀 함수다.

하지만 함수가 자기 자신을 `두 번` 호출하니 당장 머릿속에 경고음이 울려야 한다.

12장의 첫 번 째 예제에서는 간단한 변경 하나로 최적화에 성공했으나 피보나치 수열의 최적화는 그렇게 간단하지 않다. 변수에 저장할 데이터가 단지 하나가 아니기 때문이다. `fib(n-2)`과 `fib(n-1)`를 모두 계산해야 하는데 그 중 한 결과만 저장해서는 나머지 한 결과를 얻지 못한다.

컴퓨터 과학에서는 이를 일컬어 `하위 문제 중첩(overlapping subproblems)`이라 부른다.

# 12.5 메모이제이션을 통한 동적 프로그래밍

다행히도 방법이 있다. 바로 동적 프로그래밍이라는 방법을 통해서다. `동적 프로그래밍(dynamic programming)`은 하위 문제가 중첩되는 재귀 문제를 최적화하는 절차다.

(”동적”이란 단어에 너무 의미를 두지 말자. 왜 이 용어가 쓰이게 됐는지 논란이 많으나 이제부터 설명할 기법에 동적인 요소는 전혀 없다.)

동적 프로그래밍을 통한 알고리즘 최적화에는 일반적으로 두 기법 중 하나를 사용한다.

### 1. 메모이제이션(memoization)

본질적으로 메모이제이션은 먼저 계산한 함수 결과를 기억해 재귀 호출을 감소시킨다.

각 재귀 함수는 해시 테이블에 어떻게 접근할까? 함수의 두 번째 인자로 해시 테이블을 전달하면 된다.

## 12.5.1 메모이제이션 구현

해시 테이블을 함께 전달하려면 해시 테이블을 두 번재 인수로 추가해서 인수를 두 개 받도록 함수를 수정해야 한다. 이 해시 테이블을 메모이제이션의 앞부분을 따서 memo라 부르겠다.

```jsx
function fib(n, memo = {}) {
  if (n === 0 || n === 1) {
    return n;
  }

  if (!memo[n]) {
    memo[n] = fib(n - 2, memo) + fib(n - 1, memo);
  }

  return memo[n];
}
```

memo에 기본값을 할당하면 처음 호출할 때 빈 해시 테이블을 명시적으로 전달하지 않아도 된다.

보다시피 알고리즘 핵심부는 바뀌지 않았다. 여전히 재귀로 문제를 해결하며 fib 계산은 여전히 기본적으로 `fib(n - 2) + fib(n - 1)`이다. 하지만 계산하는 수가 처음 나오는 수면 그 결과를 해시 테이블에 저장하고, 이미 한 번 계산된 수면 다시 계산하지 않고 해시 테이블에서 그 값을 가져 온다.

위 함수의 빅 오는 얼마일까? N에 대해 (2N - 1) 번 호출함을 알 수 있고, O(N) 알고리즘이다.

# 12.6 상향식을 통한 동적 프로그래밍

앞서 동적 프로그래밍은 두 기법 중 하나로 가능하다고 말한 바 있다.

“상향식”이라 불리는 두 번째 기법은 훨씬 덜 세련되고 심지어 기법이라 부르기도 애매하다. `상향식`은 그저 같은 문제를 재귀 대신 (루프 같은) 다른 방식으로 해결한다는 뜻이다.

상향식이 동적 프로그래밍의 하나로 간주되는 이유는 동적 프로그래밍이 재귀적으로 풀 수 있는 문제에 대해 중첩되는 하위 문제를 중복 호출하지 않게 해주기 때문이다. 재귀 대신 반복(즉 루프)을 사용하는 것도 엄밀히 말해 이렇게 하는 방법 중 하나다.

피보나치 함수를 어떻게 상향식으로 구현하는지 알아보자

## 12.6.1 상향식 피보나치

```jsx
function fib(n) {
  if (n === 0) {
    return 0;
  }

  let a = 0;
  let b = 1;

  for (let i = 1; i < n; i++) {
    let temp = a;
    a = b;
    b = temp + a;
  }

  return b;
}
```

코드는 1부터 N까지의 간단한 루프이므로 N단계가 걸린다. 메모이제이션 방식처럼 O(N)이다.

## 12.6.2 메모이제이션 대 상향식

재귀가 매우 직관적이지 않은 이상 일반적으로 상향식을 택하는 편이 낫다. 재귀가 더 직관적이면 재귀를 사용하되 메모이제이션으로 빠르게 만들어야 한다.
